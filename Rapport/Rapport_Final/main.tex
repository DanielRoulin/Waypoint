\documentclass[a4paper]{article}
\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{courier}
\usepackage{minted}
\usepackage{pmboxdraw}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{subcaption}
\usepackage{float}
\usepackage{hyperref}

\graphicspath{ {./images/} }

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    anchorcolor=black,
    citecolor=black,
    filecolor=black,
    menucolor=black,
    runcolor=black,
    urlcolor=blue,
}
\urlstyle{same}
\setminted{
fontsize=\footnotesize,
breaklines,
}

\renewcommand\arraystretch{1.3}
\setlength{\skip\footins}{5mm}

\renewcommand*\contentsname{Contenu}
\renewcommand{\refname}{Référence}
\renewcommand{\listingscaption}{Extrait}

\title{Rapport de Travail de Maturité}
\author{Daniel Roulin \cr Fabio Dubath}
\date{Octobre 2022}

\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Introduction}
Internet est un outil qui a révolutionné notre mode de vie, il nous permet de communiquer avec le monde entier afin de découvrir et de partager tout ce qui est imaginable. Bien qu’un nombre gigantesque de personnes y ont accès, assez peu de monde ne sait réellement comment fonctionne ce réseau informatique mondial qui repose pourtant sur l’idée assez simple de faire communiquer des ordinateurs. Étant passionnés d'informatique, nous sommes vite arrivés au point où nous voulions nous immerger dans le code réseau (Networking en anglais) ce qui nous permettrait de faire des programmes mettant en communication plusieurs personnes. L’idée de faire un jeu fut assez évidente puisqu'elle nous permettrait de le faire essayer à n'importe qui. Alors quel jeu allons nous faire et comment allons nous le créer ?

\subsection{Les outils}
L’outil de base pour la création de notre jeu vidéo sera le moteur de jeu Unity. Un moteur de jeu est une application contenant du code déjà en place qui enlève aux développeurs beaucoup de tâches fastidieuses comme de s’occuper du rendu des images sur l’écran ou encore de l’exportation du jeu sur les différents systèmes d’exploitation. Unity est un moteur qui à été publié en 2005 par Unity Technologies et qui permet de faire des jeux en 2D ou 3D avec la possibilité d’exporter ces derniers sur une multitude de plateformes. Concernant le code, Unity utilise le langage C\#, qui est un langage de programmation orientée objet crée par Microsoft et destiné à développer sur la plateforme Microsoft .NET. Il est dérivé du C++ et très proche du Java dont il reprend la syntaxe générale ainsi que les concepts, y ajoutant des notions telles que la surcharge des opérateurs, les indexeurs et les délégués. Nous nous sommes aussi aidés de GitHub, qui est un service web d'hébergement et de gestion de développement de logiciels, utilisant le logiciel de gestion de versions Git ainsi que de l'outil d'organisation Trello\cite{trello} appartenant à Atlassian et basé sur le style kanban.

\subsection{Le jeu}
Le concept concept du jeu est très simple. Les joueurs, dans une arène, ont accès à des armes et peuvent s’éliminer en se tirant dessus. Quand un joueur en élimine un autre, il gagne un point et celui qui a le plus de points à la fin du temps imparti a gagné. Le concept s'inspire du style "battle royale", très populaire ces dernières années. \\
\\
Lorsqu'on démarre le jeu, on se retrouve sur le menu principal qui donne accès au menu de configuration, au bouton pour rejoindre le serveur et au bouton pour quitter le programme.

\begin{figure}[h]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\textwidth]{images/game/start_menu.png}
        \caption{Menu de début de jeu}
        \label{fig:start_menu}
    \end{subfigure}
        \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\textwidth]{images/game/option_menu.png}
        \caption{Menu de configuration}
        \label{fig:option_menu}
    \end{subfigure}
\end{figure}
Le menu de configuration permet à l'utilisateur de choisir l'adresse IP et le port du serveur sur lequel il veut se connecter, le programme indiquant si l'adresse insérée est valide.\\
\\
Une fois connecté, le joueur se retrouve dans la salle d'attente ou il peut se déplacer et configurer son nom d'utilisateur le temps que tous le monde soit là. Quand les joueurs décident de démarrer la partie, ils se positionnent tous sur le carré "GO".

\begin{figure}[h]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\textwidth]{images/game/waiting_room.png}
        \caption{Salle d'attente}
        \label{fig:waiting_room}
    \end{subfigure}
        \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\textwidth]{images/game/game.png}
        \caption{Jeu}
        \label{fig:jeu}
    \end{subfigure}
\end{figure}
Durant la partie, le joueur à accès au menu de pause qui lui permet de revenir au menu principal. Quand la partie est terminée, tous les joueurs sont emmenés au podium qui montre leur nombre d'éliminations. Puis, ils sont renvoyés vers la salle d'attente où une nouvelle partie peut être commencée.

\begin{figure}[h]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\textwidth]{images/game/pause_menu.png}
        \caption{Menu de pause}
        \label{fig:pause_menu}
    \end{subfigure}
        \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\textwidth]{images/game/podium.png}
        \caption{Podium}
        \label{fig:podium}
    \end{subfigure}
\end{figure}

\section{Structure}
Ce projet peut être séparé en deux parties: une partie matérielle (hardware) et une partie logicielle (software). En raison de problèmes d’approvisionnement dû à la récente pandémie et de la complexité inattendue de la partie logicielle, la partie matérielle à été moins développée que ce que nous souhaitions.

\subsection{Partie matérielle (Hardware)}
Cette partie consiste en une Raspberry Pi 3 modèle B+ avec une carte microSD, d’un petit câble et d’une batterie portable de 5000mAh fournissant 5V à 2.1A. La raspberry provient d’une connaissance de Fabio, qui a gracieusement accepté de nous la prêter pour notre projet.
La figure \ref{fig:images_raspberry} ci dessous montre deux photos de la Raspberry Pi, ainsi que deux photos avec la batterie.

\begin{figure}
    \includegraphics[width=0.5\textwidth]{images/hardware/Raspberry3.jpg}
    \includegraphics[width=0.5\textwidth]{images/hardware/Raspberry2.jpg}
    \includegraphics[width=0.5\textwidth]{images/hardware/Raspberry1.jpg}
    \includegraphics[width=0.5\textwidth]{images/hardware/Raspberry4.jpg}
    \caption{Images du dispositif}
    \label{fig:images_raspberry}
\end{figure}

\subsection{Partie logicielle (Software)}

La partie logicielle constitue en tout le code nécessaire au fonctionnement du jeu. Afin de conserver un historique des versions ainsi que pour pouvoir collaborer, nous avons utilisé le programme Git\cite{git}.
Notre projet est hébergé à cette adresse: \url{https://github.com/DanielRoulin/Waypoint} \\
Le plus simple pour étudier le projet consiste à télécharger le code source avec la commande suivante:
\begin{minted}{bash}
git clone https://github.com/DanielRoulin/Waypoint.git
\end{minted}
Un dossier nommé Waypoint contenant le code source sera normalement créé. \\
Voici une vue d’ensemble du projet:
\begin{minted}{text}
~/Waypoint$ tree -a -L 1
Waypoint
├── Client
├── Server
├── Design
├── Statistics
├── Rapport
└── .git
 
4 directories
\end{minted}

Tout d’abord, nous avons les deux dossiers les plus importants: Client et  Server. C’est là que se situe la plus grande partie de notre travail, séparée entre le code exécuté sur le client (téléphone ou ordinateur) et le code exécuté sur le serveur (Raspberry Pi ou VPS\cite{vps}). Puis, le dossier Raport contient ce pdf ainsi que le document \LaTeX  utilisé pour le créer. Ensuite, le dossier Design contient nos réflexions concernant la conception du boîtier et un logo, tandis que le dossier .git stocke toutes les informations nécessaires au contrôle de version. Finalement, le dossier Statistics contient les scripts générant les graphiques de la section \nameref{section:chiffres}.

\subsubsection{Server}
Ce dossier à la structure d’une application .NET classique. .NET est une plateforme de développement open source et gratuite, édité par Microsoft. Elle est basée sur le langage C\#, un langage de programmation à usage général typé statiquement orienté objet. \\
Pour installer .NET sur Ubuntu par exemple, il suffit d'exécuter cette commande:
\begin{minted}{text}
sudo apt-get update && sudo apt-get install -y dotnet6
\end{minted}
Des instructions plus détaillées sont disponibles à cette adresse: \\
\url{https://learn.microsoft.com/en-us/dotnet/core/install/linux} \\
\\
Pour lancer le projet, le plus simple consiste à l'ouvrir avec VSCode, car le dossier .vscode contient la configuration nécessaire. Sinon, pour simplement lancer le projet, exécutez la commande suivante dans le dossier Server
\begin{minted}{text}
dotnet run
\end{minted}
Et pour compiler le projet pour Linux (toujours dans le dossier Server):
\begin{minted}{text}
build GameServer.csproj -r linux-x64 -o bin/Linux/
\end{minted}
Ou pour compiler le projet pour la Raspberry Pi:
\begin{minted}{text}
build GameServer.csproj -r linux-arm -o bin/Raspberry/
\end{minted}
Après avoir compilé le projet, n'oubliez pas de copier le dossier Scenes là où vous souhaitez l'exécuter! \\
\\
Note: Si le message suivant apparaît, c'est car nous utilisons une version dépassé de .NET, car le tutoriel que nous avons suivi utilise cette dernière, et que .NET est rétrocompatible. Voir la section \nameref{section:demarche} pour plus de détails.
\begin{minted}{text}
warning NETSDK1138: The target framework 'netcoreapp3.0' is out of support and will not receive security updates in the future.
\end{minted}
Regardons maintenant en détail les différents fichiers du serveur:
\begin{minted}{text}
tree -a --dirsfirst Server
Server/
├── .vscode
│   ├── launch.json
│   ├── settings.json
│   └── tasks.json
├── bin
│   ├── Debug
│   │   └── ...
│   ├── Linux
│   │   └── ...
│   └── Raspberry
│       └── ...
├── Scenes
│   ├── Maps
│   │   ├── Map1.unity
│   │   ├── Map2.unity
│   │   ├── Map3.unity
│   │   ├── Map4.unity
│   │   └── Map5.unity
│   └── WaitingRoom.unity
├── GameServer.csproj
├── .gitignore
├── Client.cs
├── Colliders.cs
├── Constants.cs
├── GameLogic.cs
├── Item.cs
├── Packet.cs
├── Player.cs
├── Program.cs
├── Projectile.cs
├── Scene.cs
├── Server.cs
├── ServerHandle.cs
├── ServerSend.cs
├── ThreadManager.cs
└── Utilities.cs 

22 directories, 753 files
\end{minted}
Dans l’ordre, nous avons d’abord le dossier .vscode, qui contient la configuration de notre éditeur, VSCode, tasks.json avec les instructions pour compiler le projet, launch.json celle pour le déboguer et settings.json nos différents réglages de l'éditeur. \\
Puis, le dossier bin, qui n’est pas inclus sur github, contient tous nos builds pour les différentes plateformes, en l'occurrence Linux et Raspberry. \\
Ensuite, le dossier obj est créé lors de la compilation et des fichiers créé pendant l'étape intermédiaire entre la compilation et le linting. \\
Vient maintenant le dossier Scenes, qui contient une copie des terrains du client, au format .unity. Ce format s’appelle UnityYAML\cite{unityyaml} et, comme son nom l’indique, c’est le format des scènes Unity, basé sur le format YAML. Ces fichiers sont interprétés par le serveur via le script Scene.cs, qui contient un parser customisé pour ce format. Le dossier contient la salle d’attente, WaitingRoom.unity et toutes les cartes du jeu: Map1.unity, Map2.unity, ... \\
Finalement, nous avons ces quelques fichiers:
\begin{itemize}
    \item GameServer.csproj contient les réglages du projet. En voici une copie:
    \begin{minted}{xml}
<Project Sdk="Microsoft.NET.Sdk">
 <PropertyGroup>
   <OutputType>Exe</OutputType>
   <TargetFramework>netcoreapp3.0</TargetFramework>
   <RollForward>Major</RollForward>
 </PropertyGroup>
 <ItemGroup>
   <PackageReference Include="System.Numerics.Vectors" Version="4.5.0" />
   <PackageReference Include="YamlDotNet" Version="11.2.1" />
 </ItemGroup>
</Project>
    \end{minted}
    On peut voir que l’on demande au compilateur de créer un fichier exécutable, en utilisant la version 3.0 de dotnet si possible mais en acceptant n’importe quelle version au-dessus. De plus, nous importons le package System.Numerics.Vectors, qui nous permet d’utiliser des vecteurs ainsi que le package YamlDotNet\cite{yamldotnet} qui nous permet de parser du YAML.
    
    \item .gitignore contient une liste des fichiers ou dossiers que Git\cite{git} doit ignorer. En l'occurrence, on ne souhaite ignorer que les résultat de la compilation:
    \begin{minted}{text}
bin
obj
    \end{minted}
\end{itemize}
Les fichiers restants sont les scripts, qui sont le cœur du serveur. Voici un tableau résumant leurs fonctions respectives:
\begin{center}
\begin{longtable}{|l|p{10cm}|}
    \hline
    Fichier & Fonction \\
    \hline\hline
    \mintinline{text}{Program.cs}\footnotemark[1] & Premier script appelé lors de l’exécution, Program.cs est responsable du démarrage du serveur et de la game loop dans deux différents threads. Il actualise la game loop à intervalles réguliers.\\
    \hline
    \mintinline{text}{ThreadManager.cs}\footnotemark[1] & Ce script gère simplement la communication entre le thread du serveur et la game loop (main thread).\\
    \hline
    \mintinline{text}{Server.cs}\footnotemark[1] & Server.cs contient la classe la plus importante du projet, la classe Server. Cette classe stocke toutes les informations de la partie, telle que sa durée, la liste des joueurs, des objets et des projectiles, etc. Elle est responsable de l’initialisation du serveur et de la connexion des nouveaux joueurs.\\
    \hline
    \mintinline{text}{Client.cs}\footnotemark[1] & Ce fichier contient la classe Client, qui est instancié pour chaque joueur connecté. Cependant, elle n’est responsable que de la gestion de la connexion, les fonctions liées au joueur se situent dans la classe Player. Chaque Client a un Player associé et est chargé de l'initialiser et de le réinitialiser quand le client se déconnecte.\\
    \hline
    \mintinline{text}{Packet.cs}\footnotemark[1] & Cette classe contient la logique nécessaire à l’encodage et au décodage des paquets, qui sont formés d’octets. Il contient aussi la liste et le nom des différents paquets, qui doit impérativement être la même sur le client et le serveur.\\
    \hline
    \mintinline{text}{ServerSend.cs} & Cette classe contient les fonctions responsables de la construction et de l’encodage des paquets envoyés par le serveur aux clients.\\
    \hline
    \mintinline{text}{ServerHandle.cs} & Cette classe contient les fonctions responsables du décodage et de l'interprétation des paquets envoyés par les clients au serveur.\\
    \hline
    \mintinline{text}{GameLogic.cs} & C’est ici que se situe la logique du jeu. Ce script contient la fonction Update, qui est appelée à chaque tic et s’occupe de mettre à jour les joueurs, les projectiles et les objets, ainsi que les fonctions permettant de démarrer et d'arrêter le jeu.\\
    \hline
    \mintinline{text}{Scene.cs} & Ce fichier est responsable de l’interprétation des scènes, qui se situe dans le dossier Scenes. Il est responsable de trouver certains objets dans les scènes, tel que les obstacles, les éléments déclencheur d’action (trigger) ainsi que les points d’apparition (spawn points).\\
    \hline
    \mintinline{text}{Player.cs} & Cette classe est instanciée pour chaque joueur, et contient toutes leurs informations, telles que leur position, leur rotation, leur nom, leur armes, etc. Elle est aussi responsable de leur interactions, tel que récupérer des armes ou tirer des projectiles.\\
    \hline
    \mintinline{text}{Item.cs} & Cette classe est instanciée pour chaque objet du jeu, et contient toutes leurs informations, telles que leur position et type.\\
    \hline
    \mintinline{text}{Projectile.cs} & Cette classe est instanciée pour chaque projectile du jeu, et contient toutes leurs informations, telles que leur position, rotation et type. Elle est aussi responsable de changer leur position, en suivant différentes trajectoires en fonction de leur type.\\
    \hline
    \mintinline{text}{Collider.cs} & Ce fichier est responsable de détecter les collisions du jeu. Il contient deux classes: RectCollider et CircleCollider, représentant respectivement des rectangles et des cercles. Chaque entité du jeu possède un de ces collider. Chacune des classes contient une fonction permettant de vérifier qu’il n’intersecte pas avec un autre collider.\\
    \hline
    \mintinline{text}{Utilities.cs} & Cette classe contient divers fonction pratiques, liées notamment à la génération de nombres aléatoires, de la génération de position aléatoire spécifiques et du logging\\
    \hline
    \mintinline{text}{Constants.cs} & Cette classe contient toutes les constantes du jeu, telles que le nombre de tic par seconde, la taille des terrains, les caractéristiques des différentes armes et les noms par défauts des joueurs.\\ 
    \hline
\end{longtable}
\end{center}
\hrule
\textit{\footnotemark[1]Nous n’avons que très peu modifié ces fichiers, ils proviennent du tutoriel de Tom Weiland. Voir la section \nameref{section:demarche}.}

\subsubsection{Client}
Passons maintenant au deuxième grand dossier du projet, le dossier \mintinline{text}{Client}. Ce dernier contient l'entièreté du code source du client. 
Ce dossier est un projet Unity. Unity est une plateforme de développement de jeux multi plateformes, aussi basé sur le langage C\#. Le lien ci-dessous explique comment installer Unity: \url{https://unity3d.com/get-unity/download} \\
Ce projet utilise la version 2020.3.2f1, mais fonctionne peut-être sur d'autres versions. \\
\\
Voici une vue d’ensemble du projet après l’avoir téléchargé:
\begin{minted}{text}
tree -a --dirsfirst Client
Client
├── Assets
│   ├── Animations
│   │   └── ...
│   ├── Fonts
│   │   └── ...
│   ├── Graphic
│   │   └── ...
│   ├── _Heathen Engineering
│   │   └── ...
│   ├── Hexanim
│   │   └── ...
│   ├── Materials
│   │   └── ...
│   ├── Prefabs
│   │   ├── EndScreen
│   │   │   ├── Bar.prefab
│   │   │   ├── Confettis.prefab
│   │   ├── Items
│   │   │   ├── Black Item.prefab
│   │   │   ├── Blue Item.prefab
│   │   │   ├── Bronze Item.prefab
│   │   │   ├── Brown Item.prefab
│   │   │   ├── Cyan Item.prefab
│   │   │   ├── Green Item.prefab
│   │   │   ├── Lime Item.prefab
│   │   │   ├── Orange Item.prefab
│   │   │   ├── Pink Item.prefab
│   │   │   ├── Purple Item.prefab
│   │   │   ├── Red Item.prefab
│   │   │   ├── Siilver Item.prefab
│   │   │   ├── White Item.prefab
│   │   │   └── Yellow Item.prefab
│   │   ├── Leaderboard
│   │   │   └── Entry.prefab
│   │   ├── Players
│   │   │   ├── LocalPlayer.prefab
│   │   │   ├── Player [Local].prefab
│   │   │   └── Player.prefab
│   │   ├── Projectiles
│   │   │   ├── EnnemyProjectileExplode.prefab
│   │   │   ├── EnnemyProjectile.prefab
│   │   │   ├── FriendlyProjectileExplode.prefab
│   │   │   ├── FriendlyProjectile.prefab
│   │   │   └── Turret.prefab
│   │   └── SpawnPart.prefab
│   ├── Scenes
│   │   ├── Maps
│   │   │   ├── Map1.unity
│   │   │   ├── Map2.unity
│   │   │   ├── Map3.unity
│   │   │   ├── Map4.unity
│   │   │   └── Map5.unity
│   │   ├── Empty.unity
│   │   ├── End Screen.unity
│   │   └── WaitingRoom.unity
│   ├── Scripts
│   │   ├── CameraSC.cs
│   │   ├── Client.cs
│   │   ├── ClientHandle.cs
│   │   ├── ClientSend.cs
│   │   ├── DontDestroy.cs
│   │   ├── EndScreenBar.cs
│   │   ├── EndScreenManager.cs
│   │   ├── GameManager.cs
│   │   ├── Item.cs
│   │   ├── Leaderboard.cs
│   │   ├── LeaderboardEntry.cs
│   │   ├── Menu.cs
│   │   ├── Packet.cs
│   │   ├── PlayerController.cs
│   │   ├── PlayerManager.cs
│   │   ├── Projectile.cs
│   │   └── ThreadManager.cs
├── ProjectSettings
│   └── ...
├── UserSettings
│   └── EditorUserSettings.asset
├── .vscode
│   └── settings.json
└── .gitignore
 
55 directories, 1635 files
\end{minted}
\hrule
\textit{Note: Les fichiers .meta ne sont pas affichés. Ils sont créé par Unity ne contiennent que des métadonnées concernant les fichiers du même nom.} \\
\\
Pour commencer nous avons le dossier {.vscode}, qui, comme sur le serveur, contient la configuration de notre éditeur. En l’occurrence, le fichier {settings.json} contient simplement une liste de fichier à ne pas montrer dans l’éditeur, pour simplifier l’affichage.
Puis, les dossiers {ProjectSettings} et {UserSettings} contiennent respectivement les réglages du projet et ceux de l’utilisateur.
Ensuite, les dossiers Animations, {Fonts} et {Materials} contiennent des animations, des polices d’écriture ainsi que des matériaux (texture). 
Le dossier {Prefab} contient tous les prefabs du projet. Un prefab, dans Unity, est un objet pouvant être instancié plusieurs fois dans une scène. Par exemple, les joueurs et les projectiles sont des prefabs.
Nous avons aussi le dossier {Scenes} qui contient tous les terrains du jeu, et doit être exactement le même que sur le serveur.
Finalement, nous avons le dossier {Scripts}, qui contient tous les scripts du projet. \\
\\
Voici un tableau résumant leurs fonctions respectives:
\begin{center}
\begin{longtable}{|l|p{10cm}|}
    \hline
    Fichier & Fonction \\
    \hline\hline
    \mintinline{bash}{ThreadManager.cs}\footnotemark[1] & Ce script gère simplement la communication entre le thread du client et la game loop (main thread).\\
    \hline
    \mintinline{bash}{Client.cs}\footnotemark[1] & Cette classe est responsable de la connexion avec le serveur. Elle gère le transfert de paquets via TCP et UDP.\\
    \hline
    \mintinline{bash}{Packet.cs}\footnotemark[1] & Ce fichier est le même que sur le serveur.\\
    \hline
    \mintinline{bash}{ClientSend.cs} & Cette classe contient les fonctions responsables de la construction et de l’encodage des paquets envoyés par le client au serveur, tels que les boutons qu’il presse, sa rotation ou son nom d’utilisateur.\\
    \hline
    \mintinline{bash}{ClientHandle.cs} & Cette classe contient les fonctions responsables du décodage et de l'interprétation des paquets envoyés par le serveur au client, tel que la position des autres entitées ou le nom des autres joueurs.\\
    \hline
    \mintinline{bash}{GameManager.cs} & Cette classe est la plus importante du client, car elle est responsable du déroulement du jeu. Par exemple, elle s’occupe de charger les différentes cartes, de démarrer et terminer les parties et de faire apparaître les joueurs, les projectiles et les objets sur la scène.\\
    \hline
    \mintinline{bash}{Menu.cs} & Cette classe gère tous les menus (UI) du jeu.\\
    \hline
    \mintinline{bash}{PlayerManager.cs} & Cette classe est associée à chaque joueur apparaissant sur la scène, et est responsable de leur apparence et comportement.\\
    \hline
    \mintinline{bash}{PlayerController.cs} & Cette classe s’occupe d'envoyer au serveur le nom du joueur local, ainsi que les différents boutons qu’il presse.\\
    \hline
    \mintinline{bash}{Item.cs} & Cette classe est instanciée pour chaque objet du jeu, et contient toutes leurs informations, telles que leur position et type.\\
    \hline
    \mintinline{bash}{Projectile.cs} & Cette classe est associée à chaque projectile et s’occupe de les déplacer et les détruire.\\
    \hline
    \mintinline{bash}{CameraSC.cs} & Ce script est rattaché à la caméra et est responsable de son mouvement, pour qu’elle suive le joueur de façon fluide.\\
    \hline
    \mintinline{bash}{Leaderboard.cs} & Cette classe gère le tableau des scores qui apparaît en haut à droite durant une partie. Il se charge notamment de trier les joueurs par scores.\\
    \hline
    \mintinline{bash}{LeaderboardEntry.cs} & Cette classe est associée à chaque entrée du tableau des scores et stocke leur position et texte et est responsable de l’animation de leur position.\\
    \hline
    \mintinline{bash}{EnsScreenManager.cs} & Ce fichier contient la classe responsable de l’écran apparaissant à la fin d’une partie\\
    \hline
    \mintinline{bash}{EndScreenBar.cs} & Cette classe, rattachée aux barres apparaissant à la fin d’une partie, est responsable de leur mouvement et de leur apparence.\\
    \hline
    \mintinline{bash}{DontDestroy.cs} & Ce script est très petit, et ne fait qu'indiquer au compilateur de ne pas détruire certains éléments quand une nouvelle carte est chargée.\\
    \hline
\end{longtable}
\end{center}
\hrule
\textit{\footnotemark[1]Nous n’avons que très peu modifié ces fichiers, ils proviennent du tutoriel de Tom Weiland. Voir la section Démarche.}

\subsection{Protocole}
Pour communiquer entre eux, le client et le serveur utilisent deux protocoles de base: TCP\cite{tcp} et
UDP\cite{udp}. Ils transfèrent des séquences d’octets, appelées paquets (packets). La signification d’un paquet dépend de son \mintinline{text}{packetId}, mais aussi de l’état du client qui le reçoit. Par défaut, le port 26950 est utilisé. \\
Voici une vue d’ensemble du format d’un paquet:
\begin{center}
\begin{tabular}{|l|l|p{10cm}|}
    \hline
    Nom & Type & Notes \\
    \hline\hline
    \mintinline{text}{length} & int & Longueur du message. Est égale à la longueur du packet id + la longueur des donnée du packet \\
    \hline
    \mintinline{text}{packetId} & int & Type du paquet, voir les sections suivantes \\
    \hline
    \mintinline{text}{data} & bytes & Liste d’octet dépendant du packet id \\
    \hline
\end{tabular}
\end{center}
Le même format est utilisé si la connexion est en TCP ou en UDP.

\subsubsection{TCP OU UDP ?}
Le jeu utilise deux types de connexion: TCP et UDP. TCP à l’avantage de garantir l'arrivée d’un paquet si un client peut le recevoir, ainsi que conserver l’ordre des paquets. UDP est plus rapide que TCP, mais ne vérifie pas la réception ni l’ordre des paquets. C’est pourquoi TCP est privilégié pour les messages importants envoyés qu'une seule fois, tandis qu’UDP est utilisé pour les messages envoyés à chaque tic. En pratique, seul le temps, la position et la rotation utilisent UDP. Un autre inconvénient d’UDP que nous avons remarqué est que certains réseaux, notamment celui de notre collège, semblent bloquer ce protocole. C’est pourquoi nous souhaitions ajouter à notre jeu un mode “TCP only”, ce que nous n'avons malheureusement pas eu le temps de faire.

\subsubsection{Le client (n’) est (pas) roi}
Lorsque l’on développe un jeu en ligne, il est nécessaire de choisir la liberté du client. Par exemple, le client pourrait simplement envoyer sa position sous forme de vecteur au serveur. Cependant, cela implique au serveur de faire confiance au client pour qu’il n’envoie pas des positions interdites ou erronées, car ce dernier pourrait ainsi se téléporter. C’est pourquoi notre jeu, comme la plupart des jeux en ligne, demande au client d’uniquement envoyer ses clics de boutons, puis le serveur envoie la position du joueur comme celle de n’importe quelle autre joueur, sous forme de vecteur. De plus, si plusieurs paquet de mouvement sont envoyés en un seul tic, le serveur n’applique que le dernier reçu. Cela permet de contrôler la vitesse des joueurs. La seule exception à cette règle est la rotation du joueur, que le client contrôle entièrement afin d’éviter un délai nettement visible

\subsubsection{Types de données}
Voici un tableau résumant les 6 types de donnée est utilisé par le protocole:
\begin{center}
\begin{tabular}{|l|m{1.5cm}|m{5cm}|m{5cm}|}
    \hline
    Nom & Taille (octets) & Encode & Notes \\
    \hline\hline
    byte & 1 & Un octet, nombre entier entre 0 et 255 & Unsigned 8-bit integer \\
    \hline
    int & 4 & Un nombre entier entre -2147483648 et 2147483647  & Signed 32-bit integer, two's complement \\
    \hline
    float & 4 & Un nombre à virgule flottante & A single-precision 32-bit IEEE 754 floating point number \\
    \hline
    bool & 1 & Vrai ou faux & True is encoded as 0x01, false as 0x00. \\
    \hline
    string (n) & 4 + n & Une séquence de caractère du tableau ASCII (7 bits) & ASCII (7 bits) string prefixed with its size in bytes as an int \\
    \hline
    vector2 & 2 * 4 & Un vecteur 2 dimensionnel & X as a float, followed by Y as a float \\
    \hline
\end{tabular}
\end{center}
Ces représentations proviennent simplement de la fonction \mintinline{csharp}{BitConverter.GetBytes} du namespace\cite{namespace} \mintinline{csharp}{System}.

\subsubsection{Paquets}
Une liste détaillée des paquet se situe dans l'annexe \ref{annexe:paquets}.
\newpage
\section{Quelques chiffres}
\label{section:chiffres}
\subsection{Lignes de code en fonction du temps}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/stats/lines_of_code.png}
    \caption{Lignes de code en fonction du temps}
    \label{fig:lines_of_code}
\end{figure}
Le graphique \ref{fig:lines_of_code} montre le nombre de lignes contenu dans les fichiers .cs (fichiers de code C\#) en fonction du temps. Il a pu être fait en remontant dans l’historique des versions via Git. On constate très bien la réorganisation du projet mi mars 2022, suivi de l’ajout du code du tutoriel, puis l’adaptation du projet à nos besoin fin mars. Les changements brutaux sont dus à des conflits de fusion de notre code (merge conflicts) qui ont été résolus avec plus ou moins de succès. La grosse vallée fin mai représente un changement de nos menus (UI), d'où la suppression et l’ajout rapide de code. On peut ensuite voir les vacances, de juin à début mai. L’agitation fin mai correspond à de nouveau des conflits de merge, car nous travaillions beaucoup en même temps aux mêmes endroits. Finalement, les changements du mois d’octobre représente notre débogage, c’est pourquoi peu d’ajouts de code peuvent être observés.

\newpage
\subsection{Contributions}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/stats/contributions.png}
    \caption{Contributions}
    \label{fig:contributions}
\end{figure}
Le graphique \ref{fig:contributions} montre le nombre de commits par personne. A première vue, on pourrait penser que Fabio (Theel) à beaucoup moins contribué aux projets. Cependant, ce graphique montre les commits, qui ne sont pas représentatif du travail fourni. En effet, nous avons tous les deux différentes façons de commit. Par exemple, Daniel préfère créer un commit à chaque changement tandis que Fabio commit quand il a fini toute une partie. De plus, Fabio s’est aussi concentré sur la partie artistique, qui n’est pas mesurée par les commits.

\newpage
\subsection{Commits}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/stats/commits.png}
    \caption{Commits}
    \label{fig:commits}
\end{figure}
Finalement, le graphique \ref{fig:commits} montre l'évolution du nombre de commits en fonction du temps. On y voit clairement nos deux différents styles de commit, ainsi que les différentes périodes du projet. Le décalage entre les deux courbes est aussi dû au fait que le repo était à l’origine utilisé uniquement pour le serveur, avant d’avoir fusionné avec le reste du projet (voir la section démarche). C’est pourquoi les premiers commits n’ont été faits uniquement par Daniel et commencent plus tôt.

\newpage

\section{Démarche}
\label{section:demarche}
Dans cette section, nous verrons chaque étape du processus de création  du projet, de la première idée au produit fini. 
\subsection{L’idée}
Tout à commencé en cours de philo, durant une phase soudaine d'ennui profond, et que nous nous somme mis à discuter. C'est la que nous avons réalisé qu'il n’était alors pas possible de jouer à des jeux en ligne sans être connecté à Internet, et qu'il était possible de changer cela. Il se trouve que nous avons eu cette réalisation à peu près au moment de choisir le sujet de notre travail de maturité, et que nous avions à nous deux l’essentiel des connaissances nécessaires pour le mener à bien. Cependant, simplement fabriquer un boîtier fonctionnant à la fois comme modem wifi et serveur n’est pas aussi complexe que ça, c’est pourquoi nous avons aussi décidé de développer un jeu pouvant marché avec ce dispositif. C’est d’ailleurs la partie du projet qui nous à pris le plus de temps.
Nous nous sommes donc inscrits pour un travail pratique à deux, choisissant M. Kessler, notre professeur d’application des mathématiques et membre de la commission de validation des TMs pour nous accompagner. Ce dernier point nous a été très utile, car notre projet a été immédiatement validé, et nous nous sommes donc tout de suite mis au travail.

\subsection{Raspberry Pi}
Nous avons donc commencé par chercher une Raspberry Pi\cite{raspberry}, car c'est la base de la partie matérielle. Cependant, nous avons été très vite confrontés à un problème: Elles n'étaient plus en stock nulle part et les meilleures estimations prévoyaient une livraison vers fin 2022. En effet, la récente pandémie de Covid 19 a causé une pénurie mondiale de circuits imprimés, qui sont des composés indispensables à la fabrication de puces électroniques et donc de Raspberry Pis. De plus, la demande à elle aussi fortement augmenté en 2021. C'est pourquoi la Raspberry Pi fondation a eu de gros problèmes de stock et a décidé de prioriser les clients professionnels qui dépendent de Raspberry Pi pour faire fonctionner leurs entreprises.\footnote{\url{https://www.raspberrypi.com/news/production-and-supply-chain-update/}} \\
Heureusement, Fabio connaissait d'un camp d'informatique Gérard, vice-président de Caritas jeunesse et surtout passionné d'informatique, qui a accepté de nous en prêter une en attendant. \\
C'est ainsi que le 9 mars 2022, Fabio est allé cherché une Raspberry Pi 3 Model B+ chez lui et que nous avons pu commencé à travailler.

\subsubsection{Découverte de la carte et génération de wifi}
Après l'avoir reçu, il a fallu configurer la Raspberry. Pour commencer, il nous fallait un périphérique de stockage pour stocker le système d'exploitation. Nous nous sommes donc dirigé vers la Fnac de Balexert, afin d'acheter une carte micro SD de 16GB, visible sur la figure \ref{fig:microsd}
\begin{wrapfigure}{R}{0.25\textwidth}
    \centering
    \includegraphics[width=0.25\textwidth]{images/hardware/microSD.jpeg}
    \caption{Carte micro SD à coté d'une pièce de 1 franc pour l'échelle}
    \label{fig:microsd}
\end{wrapfigure}
Puis, il a fallu installer un système d'exploitation sur la carte SD. Nous avons donc suivis les instructions de la documentation officielle\footnote{\url{https://www.raspberrypi.com/documentation/computers/getting-started.html\#installing-the-operating-system}}, et avons installer Raspberry Pi Imager sur l'ordinateur de Daniel. Puis, nous avons sélectionné le système d'exploitation Raspberry Pi OS Lite (32-bit), car notre modèle à une architecture en arm32\cite{arm32} et que nous n'avions pas besoin d'un environnement de bureau\cite{desktopenv}. Ensuite, nous avons installé et paramétré le programme \mintinline{text}{ssh} \cite{ssh}, afin de pouvoir accéder à la carte à distance. Finalement, l'avons configurée pour quelle puisse émettre son propre réseau WiFi, en suivant à nouveau les instructions officielle\footnote{\url{https://www.raspberrypi.com/documentation/computers/configuration.html\#setting-up-a-routed-wireless-access-point}}. D'ailleurs, Daniel avait constaté une faute de frappe sur la documentation. Mais comme le site était Open Source\cite{opensource}, il a simplement fait une pull request, qui a été acceptée quelques jours après.\footnote{\url{https://github.com/raspberrypi/documentation/commit/e7e2d7ffcba31cf6ad233fc4a70dbfe623a820f4}} \\
Finalement, la carte créait un réseau wifi. Il ne restait plus "que" à faire le jeu. 

\subsection{Tutoriel de Tom Weiland}
Nous avions tous les deux déjà programmé des jeux, mais nous n'avions aucune expérience des jeux en ligne. Nous avons donc étudié les différentes façon d'en créer un avec Unity, le moteur de jeu que nous souhaitions utiliser. Il existait de nombreuses solutions offertes directement par la plateforme, mais la plupart ne semblaient pas assez complexes pour nos besoins et leurs critiques étaient plutôt négatives. De plus, la plupart utilisait Unity Server, mais ce programme ne pouvait pas se compiler pour notre architecture de CPU (arm32\cite{arm32}). Il était aussi très lourd et ne nous semblait pas nécessaire pour notre utilisation.\\
C'est ainsi que nous avons découvert Tom Weiland et son fabuleux tutoriel\cite{tomweiland} sur le Networking en C\#. Son projet était basé sur .NET\cite{dotnet}, qui utilise le même langage que Unity.  \\
Cependant, nous avons quand même du l'adapté à nos besoin. En effet, son client était en 3D, tandis que nous voulions faire un jeux en 2D. De plus, il a fallut changer l'interface utilisateur, les graphismes, ainsi que bien sûr, le fonctionnement du jeux lui même. La figure \ref{fig:tutorial} montre ce tutoriel.
\begin{figure}
	\centering
    \includegraphics[width=0.9\textwidth]{images/tutorial.png}
    \caption{Jeu de Tom Weiland}
    \label{fig:tutorial}
\end{figure}

\subsection{Chronologie}
\subsubsection{9 Mars 2022}
Comme dit précédemment, c'est à cette date que nous avons reçu la Raspberry Pi

\subsubsection{17 Mars 2022}
C'est à ce moment la que nous avons réorganisé le projet, qui été originalement consacré à la création du WiFi, pour qu'il corresponde à la structure qu'il a aujourd'hui, qui correspond à celle du tutoriel. 

\subsubsection{18 Mars 2022}
Création de notre Trello\cite{trello}. La figure \ref{fig:trello} montre une capture d'écran de l'état de notre board à la fin du projet.
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/trello.png}
    \caption{Capture d'écran de notre Trello à la fin du projet.}
    \label{fig:trello}
\end{figure}

\subsubsection{22 Mars 2022}
C'est à cette date que Fabio à pu rejoindre le projet, car en raison d'un manque de temps et de divers problèmes techniques, il n'a pas pu le faire avant cette date. Mais il se dépêcha de se mettre au travail, avec le commit légendaire "[Fabio] joined the game"\footnote{\url{https://github.com/DanielRoulin/Waypoint/commit/1bb1d6869941d451d384b7a802145543b2b81c72}} et en ajoutant les personnages qu'il avait dessiné précédemment, visible à la figure \ref{fig:players}, qui n'ont malheureusement pas finis pas dans la version finale. Cependant, nous avons aussi expérimenté notre premier merge conflict, car nous utilisions différentes versions d'Unity. C'est aussi à ce moment la que nous avons finis de suivre le tutoriel et que nous avons commencé à travaillé sur notre jeu, notamment en créant un script pour importer les scènes Unity sur notre serveur.

\begin{figure}
	\centering
    \includegraphics[width=0.25\textwidth]{images/players/back.png}
    \includegraphics[width=0.25\textwidth]{images/players/side.png}
    \includegraphics[width=0.25\textwidth]{images/players/forward.png}
    \caption{Dessins de joueurs par Fabio qui n'ont pas finis dans la version finale}
    \label{fig:players}
\end{figure}

\subsubsection{22 au 28 Mars 2022}
Entre ces deux dates,  nous avons ajouter les animations des joueurs et les objets, qui deviendront plus tard les armes, et Fabio à commencé à travailler sur les trajectoires des projectiles. De plus, Daniel a ajouté le parsing des scènes sur le serveur.

\subsubsection{28 Mars au 1 Mai 2022}
Durant cette période, nous avons principalement travaillé sur les mécaniques de base, telle que la réapparition des joueurs, la salle d'attente et les conditions de début et de fin d'une partie. Nous avons aussi commencé à améliorer l'interface utilisateur.

\subsubsection{1 au 14 Mai 2022}
C'est à ce moment que nous avons ajouté les collisions au serveur, créé toutes les maps actuelles, visible sur la figure \ref{fig:maps} avec le tileset\cite{tileset} de Fabio, continué à travailler sur l'interface du client et essayé d'automatiser la compilation du client et du serveur avec Github Action\footnote{Github Action est un service proposé par Github permettant d'exécuter du code sur leur serveur à chaque commits.},  ce qui n'a malheureusement pas abouti. Nous avons aussi corriger quelles que bugs que nous avons trouvé.

\begin{figure}
	\centering
    \includegraphics[width=0.9\textwidth]{images/game/maps.png}
    \caption{Différentes cartes de jeux}
    \label{fig:maps}
\end{figure}


\subsubsection{11 au 29 Août 2022}
Après deux mois de pause pendant les vacances d'été, nous avons continué à travailler sur le projet. Pour commencer, Fabio à ajouter plein d'armes et d'objets et à créé un système modulaire permettant de créer des armes en fonction de différents paramètres. Puis, Daniel a séparé les différentes map dans leur propre scène (fichier). Cela nécessita aussi de récrire le code du serveur, et fut la cause de notre plus gros merge conflict, comme nous pouvons le voir à la Figure \ref{fig:conflict}

\begin{figure}
	\centering
    \includegraphics[width=0.9\textwidth]{images/conflict.png}
    \caption{Diagramme montrant les différentes branches du projet pendant le conflit}
    \label{fig:conflict}
\end{figure}
\subsubsection{30 Août au 19 Septembre}
Durant cette dernière période, nous n'avons pas ajouté de fonctionnalités majeures, mais nous nous sommes concentrés sur la correction de bugs, l'amélioration des menus, avec notamment l'ajout du menu option et pause, ainsi que des changement plutôt de l'ordre graphique. 

\subsubsection{19 Septembre à fin Octobre}
Nous avons rédiger notre rapport, nettoyé le code et les fichiers du projet et fait les statistiques à ce moment là.

\section{Problèmes rencontrés}
\subsection{FPS du serveur}
Le premier problème rencontré à été un problème d'optimisation. En effet, le serveur est un programme relativement simple qui peut être très bien exécuté par l'ordinateur. Mais cette facilité faisait que le programme était exécuté plusieurs centaines de fois par seconde, ce qui prenait trop de performances et empêchait une bonne synchronisation entre le serveur et les clients. La solution était simple, il a suffit de limiter le nombre d'exécutions par seconde à un nombre raisonnable avec le code ci-dessous qui "mets en pause" l'exécution du programme pour qu'il n'y aie qu'une exécution par 30$^{\acute{e}me}$ de seconde:

\begin{listing}[!h]
\begin{minted}{csharp}
while (isRunning)
{
    while (_nextLoop < DateTime.Now)
    {
        GameLogic.Update();
        _nextLoop = _nextLoop.AddMilliseconds(Constants.MS_PER_TICK);
        if (_nextLoop > DateTime.Now)
        {
            Thread.Sleep(_nextLoop - DateTime.Now);
        }
    }
}
\end{minted}
\caption{Code pour la limitation du nombre d'exécutions par seconde}
\label{extrait:fps}
\end{listing}

\subsection{Scene parsing}
Quand nous avons commencé à créer des cartes pour les joueurs, nous nous sommes très vite heurtés à un problème: Comment synchroniser les terrains du serveur avec ceux du client? En effet, il est nécessaire que les deux connaissent la position des obstacles, des points d'apparition et des déclencheurs d'événement, le premier afin d'appliquer la logique du jeu, le deuxième afin d'afficher correctement ces éléments. La meilleure solution que nous avons trouvé consiste en ajoutant des informations destiné au serveur sur les scènes du clients, puis de les copier sur le serveur pour qu'il puisse les interpréter. Cependant, il n'existait pas de parser\cite{parser} pour le format des scènes utilisé par Unity (UnityYaml\cite{unityyaml}). En revanche, comme son nom l'indique, le format est basé sur le YAML\cite{yaml}, pour lequel des libraires existent en C\#. Nous avons donc décidé de créé notre propre parser par dessus, que l'on peut trouver dans le fichier Scene.cs.

\subsubsection{Format}
\begin{listing}[!h]
\begin{minted}{yaml}
%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!1 &835401395
GameObject:
  m_ObjectHideFlags: 0
  m_Component:
  - component: {fileID: 835401396}
  m_Name: Square (2)
  m_TagString: ServerCollideable
  m_IsActive: 1
--- !u!4 &835401396
Transform:
  m_ObjectHideFlags: 0
  m_GameObject: {fileID: 835401395}
  m_LocalRotation: {x: -0, y: -0, z: -0, w: 1}
  m_LocalPosition: {x: 0, y: 7.5, z: 0}
  m_LocalScale: {x: 30, y: 1, z: 1}
  m_Children: []
  m_Father: {fileID: 1928389500}
  m_RootOrder: 1
  m_LocalEulerAnglesHint: {x: 0, y: 0, z: 0}
\end{minted}
\caption{Example d'un fichier UnityYaml avec un seul GameObject}
\label{extrait:scene}
\end{listing}
Comme on le voit dans l'extrait \ref{extrait:scene}, un fichier comporte d'abord un en-tête. Puis, il ai composé d'une liste de fichier Yaml valide, séparé par un une courte chaîne de caractères. contenant leur type et leur id. Chaque fichier représente un composant de la scène, liés entre eux par leur id pour former une hiérarchie cohérente. 

\subsubsection{Parsing}
Pour commencer, nous découpons le fichier par l'en-tête de chaque sous fichiers, qui commence toujours par \mintinline{text}{---}. Puis, nous parsons chaque fichier en utilisant la librairie YamlDotNet\cite{yamldotnet}. Ensuite, nous ajoutons le résultat à un dictionnaire, avec pour index son \mintinline{text}{object_id}. C'est la fonction \mintinline{csharp}{ParseObjects}, visible dans l'extrait \ref{extrait:parseobjects}. 
\begin{listing}[!ht]
\begin{minted}{csharp}
private void ParseObjects()
{
    string file = File.ReadAllText(path);
    string[] files_array = file.Split("--- ");
    List<string> files = files_array.ToList<string>();
    files.RemoveAt(0);

    objects = new Dictionary<string, dynamic>();
    foreach (var f in files)
    {
        string[] splits = f.Split("\n", 2);
        string header = splits[0];
        string document = splits[1];
        string object_id = header.Split("&")[1];

        objects[object_id] = ParseYaml(document);
    }
}
\end{minted}
\caption{Fonction \mintinline{csharp}{ParseObjects}}
\label{extrait:parseobjects}
\end{listing} \\
Ensuite, dans la fonction \mintinline{csharp}{ParseScene}, visible dans l'extrait \ref{extrait:parsescene}, nous étudions chaque objets parsé et vérifions le tag de chaque \mintinline{csharp}{GameObject}:
\begin{itemize}
\item Si c'est un \textit{ServerCollideable}, nous le transformons en un collider du serveur avec la fonction \mintinline{csharp}{ObjectToCollider} et l'ajoutons à la liste d'obstacle de cette scène.
\item Si c'est un \textit{ServerTrigger}, nous le transformons aussi en collider et assignons la variable \mintinline{csharp}{trigger}. Il ne peut donc y avoir qu'un seul trigger par scène, et seule la scène {WaitingRoom} ne possède de trigger.
\item Si c'est un \textit{ServerSpawn}, nous utilisons la fonction \mintinline{csharp}{ObjectToVector2} pour le transformer en vecteur et ajoutons ce vecteur à la liste de points d'apparitions du serveur. 
\end{itemize}
\begin{listing}[H]
\begin{minted}{csharp}
foreach (KeyValuePair<string, dynamic> element in objects)
{
    string type = ((IDictionary<String, Object>)element.Value).Keys.First();

    if (type == "GameObject")
    {
        dynamic gameObject = element.Value.GameObject;
        string tag = gameObject["m_TagString"];

        switch (tag)
        {
            case "ServerCollideable":
                obstacles.Add(ObjectToCollider(gameObject));
                break;
            case "ServerTrigger":
                trigger = ObjectToCollider(gameObject);
                break;
            case "ServerSpawn":
                Vector2 spawn_position = ObjectToVector2(gameObject);                            
                mapSpawns.Add(spawn_position);
                break;
        }

    }
}
if (!obstacles.Any())
{
    throw new Exception($"No obstacles found in scene {path}");
}
\end{minted}
\caption{Fonction \mintinline{csharp}{ParseScene}}
\label{extrait:parsescene}
\end{listing}

\subsubsection{Fonctions ObjectToCollider et ObjectToVector2}
\begin{listing}[!h]
\begin{minted}{csharp}
private RectCollider ObjectToCollider(dynamic gameObject)
{
    foreach (var component in gameObject["m_Component"])
    {
        string fileID = component["component"]["fileID"];
        dynamic component_object = objects[fileID];
        string component_type = ((IDictionary<String, Object>)component_object).Keys.First();

        if (component_type == "Transform")
        {
            dynamic transform = component_object.Transform;
            if (float.Parse(transform["m_LocalRotation"]["x"]) != 0 ||
                float.Parse(transform["m_LocalRotation"]["y"]) != 0 ||
                float.Parse(transform["m_LocalRotation"]["z"]) != 0)
            {
                throw new Exception($"[Import Error]: GameObject {gameObject["m_Name"]} is rotated. This is not supported");
            }

            return new RectCollider(
                new Vector2(float.Parse(transform["m_LocalPosition"]["x"], CultureInfo.InvariantCulture), float.Parse(transform["m_LocalPosition"]["y"], CultureInfo.InvariantCulture)),
                new Vector2(float.Parse(transform["m_LocalScale"]["x"], CultureInfo.InvariantCulture), float.Parse(transform["m_LocalScale"]["y"], CultureInfo.InvariantCulture))
            );
        }
    }
    throw new Exception($"[Import Error]: GameObject {gameObject["m_Name"]} does not have a transform component");
}
\end{minted}
\caption{Fonction \mintinline{csharp}{ObjectToCollider}}
\label{extrait:objecttocollider}
\end{listing}
Dans cette fonction, qui apparaît dans l'extrait \ref{extrait:objecttocollider}, nous récupérons le composant \mintinline{csharp}{Transform} de l'objet reçu en entré, qui contient des information sur sa position, sa rotation et sa taille. Nous créons ensuite un collider à partir de ces informations. Il est intéressant de noter l'utilisation du type \mintinline{csharp}{dynamic,} qui nous permet d'avoir des variable dont on ne connais pas le type, telle que le résultat du parsing. De plus, les colliders ne peuvent pas gérer les transformations, donc le programme rapporte une erreur si un objet en possède. Finalement, nous utilisons aussi l'option \mintinline{csharp}{CultureInfo.InvariantCulture} quand nous transformons la chaîne de caractères en nombre à virgule flottante, car sans cette option, le programme marchait sur l'ordinateur de Daniel mais par sur celui de Fabio, car ce dernier était en français. La fonction \mintinline{csharp}{ObjectToCollider} est similaire à la précédente, sauf qu'elle retourne un vecteur à deux dimensions plutôt qu'un collider.

\subsubsection{Améliorations}
En rédigeant ce texte, nous avons réalisé qu'il était possible d'optimiser ce programme en n'utilisant le parser YAML que quand il est nécessaires. En effet, nous avons réalisé après coup que le type de composant est présent dans l'en-tête de chaque sous-fichiers. Il serait donc possible de ne parser que les fichiers de type \textit{GameObject} et \textit{Transform}.

\subsection{Tri du classement}
\begin{figure}[H]
	\centering
    \includegraphics[width=0.4\textwidth]{images/game/leaderboard1.png}
    \includegraphics[width=0.4\textwidth]{images/game/leaderboard2.png}
    \caption{Images montrant le classement des joueurs, avec à droite une situation ou deux joueurs on le même score.}
    \label{fig:leaderboard}
\end{figure}
Un problème intéressant que Daniel a rencontré en travaillant sur l'interface du client fut le suivant: comment trier et afficher le score des joueurs? En effet, la solution naïve serait de simplement d'ordonner les joueurs par ordre croissant et leur donner une position dans le classement correspondant à leur rang. Cependant, il se trouve que plusieurs joueurs peuvent avoir le même score, ce qui peut créé des erreurs ou afficher des entrées du classement par dessus d'autre. De plus, le rang des joueurs peut ne pas être continu, comme on le voit à droite de la figure \ref{fig:leaderboard}. L'extrait \ref{extrait:leaderboard} montre la solution que nous avons trouvé. \\
Pour commencer, nous utilisons les fonctions \mintinline{csharp}{GroupBy()} et \mintinline{csharp}{OrderByDescending()}, qui viennent du namespace\cite{namespace} \mintinline{csharp}{System.Linq}. Ce namespace permet  de facilement trier des listes et des dictionnaires. La première fonction permet de grouper les élément d'une liste dans un dictionnaire, en fonction d'un condition. Ici, nous regroupons toutes les entrées avec le même score. Puis, la deuxième fonction nous permet de trier ces groupes par ordre décroissant de leurs scores.  \\
Durant la suite du programme, nous utilisons deux variables: \mintinline{csharp}{totalRank} et \mintinline{csharp}{rank}. \mintinline{csharp}{totalRank} est l'ordre apparent des entrées, tandis que \mintinline{csharp}{rank} correspond au rang afficher à droite des noms des joueurs (Voir la figure \ref{fig:leaderboard}).  Ces deux valeurs sont initialisés à 1 au début du programme. Le reste du programme fonctionne de la façon suivante: \\
D'abord, on regarde chaque group trié. Pour chacun de ces groupes, on le réordonne en fonction du nom des joueurs qu'il contient, afin d'éviter que des joueurs avec le même score ne change de place lorsque l'on trie plusieurs fois le tableau. Puis, on donne à la variable \mintinline{csharp}{rank} la valeur de la variable \mintinline{csharp}{totalRank}. Cela permet d'avoir des rangs discontinus. Ensuite pour chaque entrée du groupe, on met à jour son rang et sa couleur en fonction de la variable \mintinline{csharp}{rank} et sa position en fonction de \mintinline{csharp}{totalRank}. Finalement, on ajoute 1 à la varibale \mintinline{csharp}{totalRank}. \\
C'est donc en utilisant quelque fonction de triage et deux variables que nous arrivons à résoudre le problème apparament simple du tri du classement.
\begin{listing}[H]
\begin{minted}{csharp}
public void SortLeaderboard(bool animated)
{
    var grouped = entries.GroupBy(p => int.Parse(p.Value.kills.text));
    var ordered = grouped.OrderByDescending(g => g.Key);
    int totalRank = 1;
    foreach (var group in ordered)
    {
        var reorderedGroup = group.OrderBy(entry => entry.Value.username.text);
        int rank = totalRank;
        foreach (KeyValuePair<int, LeaderboardEntry> entry in reorderedGroup)
        {
            entry.Value.rank.text = rank.ToString();
            entry.Value.transform.SetSiblingIndex(entries.Count - totalRank);
            switch (rank){
                case 1:
                entry.Value.image.color = goldColor;
                break;
                case 2:
                entry.Value.image.color = silverColor;
                break;
                case 3:
                entry.Value.image.color = bronzeColor;
                break;
                default:
                entry.Value.image.color = defaultColor;
                break;
            }
            float y = entry.Value.rectTransform.rect.height/2 - totalRank*entry.Value.rectTransform.rect.height;
            entry.Value.targetPosition = new Vector2(0, y);
            entry.Value.rectTransform.anchoredPosition = animated ? entry.Value.rectTransform.anchoredPosition : entry.Value.targetPosition;
            totalRank++;
        }
    }
}
\end{minted}
\caption{Fonction \mintinline{csharp}{SortLeaderboard}, qui donne un rang et une position à chaque joueurs en fonction de leur score. Extrait tiré du fichier \mintinline{csharp}{Leaderboard.cs} du client.}
\label{extrait:leaderboard}
\end{listing}

%\subsection{Collisions}
\subsection{Sélection des points d'apparition}
\begin{listing}[H]
\begin{minted}{csharp}
public static Vector2 RandomFreeGoodPosition(float _radius)
{
    Vector2 bestPosition = Vector2.Zero;
    float bestDistance = 0f;
    for (int i = 0; i < 20; i++)
    {
        Vector2 _position = RandomFreeCirclePositionInMap(_radius);
        float smallestDistance = 10000f;
        foreach (Item item in Server.items.Values)
        {
            float distance = Vector2.Distance(item.position, _position);
            smallestDistance = MathF.Min(smallestDistance, distance);
        }
        foreach (Client client in Server.clients.Values)
        {
            if (client.player == null) continue;
            float distance = Vector2.Distance(client.player.position, _position);
            smallestDistance = MathF.Min(smallestDistance, distance);
        }
        if (bestDistance < smallestDistance)
        {
            bestDistance = smallestDistance;
            bestPosition = _position;
        }
    }
    return bestPosition;
}
\end{minted}
\caption{Fonction \mintinline{csharp}{RandomFreeGoodPosition}, qui permet de générer des bonnes positions pour l'apparition d'objets et de joueurs. Tiré du fichier  \mintinline{csharp}{Utilites.cs} du serveur.}
\label{extrait:position}
\end{listing}
\noindent
Au début de la création du jeu, nous faisions naïvement apparaître les joueurs et les objets en choisissant des coordonnées X et Y aléatoirement entre 0 et la largeur et la longueur du terrain. Cependant, cette méthode comportait plusieurs problème. D'abord, il était possible que ces entités apparaissaient dans des obstacles, ce qui empêchait les joueurs de bouger et rendait les objets inaccessibles. Nous avions donc créé une fonction générant des positions aléatoires jusqu'à en trouver une qui n'intersectait aucun des obstacles de la scène. Cette solution permettait d'éviter le problème initial, mais en introduisait un autre: si un joueur est particulièrement malchanceux, il était possible qu'il apparaisse toujours désarmé en face d'un ennemi et que les armes se retrouvent toujours du coté de cet ennemis. Pour parer à cet inconvénient, nous avons rajouté une étape à la génération de positions, visible dans l'extrait \ref{extrait:position}. \\
Le fonctionnement de cette fonction est simple: on génère 20 positions grâces à la méthode précédemment expliqué, puis on choisis celle qui est la plus loin de chaque joueurs et armes. Pour se faire, on commence par initialisé deux variable, \mintinline{csharp}{bestPosition} et \mintinline{csharp}{bestDistance}, qui stocke la meilleur position et la plus grande distance trouvée pour l'instant. Puis, pour chaque positions, on regarde sa distance à l'objet ou le joueurs le plus proche. Si cette distance est supérieur à \mintinline{csharp}{bestDistance}, alors \mintinline{csharp}{bestDistance} devient cette distance et \mintinline{csharp}{bestPosition} devient la position actuelle. \\
Cette méthode nous permet d'avoir une bonne distribution des entitées sur le terrain. La qualité de cette distribution est en partie lié au nombre de positions testé. Dans notre cas, après de bref tests, 20 semblait être le meilleur compromis entre qualité et performance.

\subsection{Trajectoires des balles}
Nous avons trouvé l'idée amusante que les joueurs puissent tirer des projectiles avec des trajectoires spéciales. La trajectoire la plus difficile à implémenter à été celle sinusoïdale mais le problème à été résolu grâce au code ci-dessous qui modifie la trajectoire perpendiculaire à la direction de tir comme le sinus de la distance entre la position de tir et la position de la balle:


\begin{listing}[H]
\begin{minted}{csharp}
Vector2 dist = position - initialPos;
float totaldist = MathF.Abs(MathF.Sqrt(dist.X * dist.X + dist.Y * dist.Y));
Vector2 perp;
if (direction.Y == 0)
{
    perp = new Vector2(0, 1);
}
else
{
    perp = new Vector2(1, -direction.X / direction.Y);
}
float lenght = MathF.Sqrt(perp.X * perp.X + perp.Y * perp.Y);
perp = new Vector2(perp.X / lenght, perp.Y / lenght);
float crossZ = direction.X * perp.Y - perp.X * direction.Y;
if (crossZ < 0)
{
    perp = new Vector2(-perp.X, -perp.Y);
}
float mod = position.X / direction.X;
position += direction * speed * 2;
position += perp * speed * MathF.Cos(totaldist * frequency) * height;
\end{minted}
\caption{Code responsable de la trajectoire des balles sinusoïdale. Tiré du fichier  \mintinline{csharp}{Projectile.cs} du serveur.}
\label{extrait:projectile}
\end{listing}

\subsection{Style artistique}
Bien que nous voulions à la base créer un jeu dans le style "pixel art", nous nous sommes plutôt dirigés vers un style "néon" qui était plus simple, plus rapide à réaliser et qui allait mieux avec l'ambiance du jeu. Le style graphique à pu être renforcé grâce a du post-processing (traitement d'image) qui donne au jeu ce ton explosif et lumineux.

\begin{figure}[h]
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\textwidth]{images/game/start_menu.png}
        \caption{Jeu avec post-processing}
        \label{fig:post_processing}
    \end{subfigure}
        \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=0.9\textwidth]{images/game/no_postfx.png}
        \caption{Jeu sans post-processing}
        \label{fig:no_post_processing}
    \end{subfigure}
\end{figure}

\newpage
\begin{thebibliography}{}
\bibitem{vps}
	Un VPS (Virtual Private Server) est un serveur dédié pouvant être loué au près d'hebergeurs web. Plus d'informations à cette addresse: \\
    \url{https://fr.wikipedia.org/wiki/Serveur_d\%C3\%A9di\%C3\%A9_virtuel}

\bibitem{dotnet}
	.NET est une plateforme de développement dotée d'outils et de bibliothèques permettant de créer tout type d'application, notamment web, mobile, desktop, jeux, IoT, cloud et microservices. C'est la plateforme de notre serveur. Plus d'information à ces adresses: \\ 
    \url{https://dotnet.microsoft.com} \\
    \url{https://fr.wikipedia.org/wiki/.NET_Core}

\bibitem{tomweiland}
	Tom Weiland est un créateur de contenu et programmeur, connu notamment pour ses tutoriel sur Unity et surtout sur le networking en C\#, qui nous ont servis de base pour ce projet. Ci-joint l'addresse de son site web, son profil github et le tutoriel que nous avons suivis:
    \begin{itemize}
    	\item Site web: \url{https://tomweiland.net/}
        \item Github: \url{https://github.com/tom-weiland}
        \item Tutoriel: \url{https://youtube.com/playlist?list=PLXkn83W0QkfnqsK8I0RAz5AbUxfg3bOQ5}
    \end{itemize}

\bibitem{opensource}
	Du code est dit Open Source si il est mis à disposition gratuitement pour d'éventuelles modifications et redistributions. Plus d'information à cette addresse: \\ 
    \url{https://en.wikipedia.org/wiki/Open_source}

\bibitem{ssh}
	Le protocole Secure Shell (\mintinline{text}{ssh}) est un protocole de réseau cryptographique permettant d'exploiter des services réseau en toute sécurité sur un réseau non sécurisé. Ses applications les plus notables sont la connexion à distance et l'exécution de lignes de commande. Plus d'information à cette addresse: \\
    \url{https://fr.wikipedia.org/wiki/Secure_Shell}
    
\bibitem{raspberry}
	La Raspberry Pi est un nano-ordinateur monocarte à processeur ARM de la taille d'une carte de crédit conçu par des professeurs du 	  département informatique de l'université de Cambridge, très populaire pour ce genre de projet.
    Plus d'information à ces adresses: \\ 
    \url{https://fr.wikipedia.org/wiki/Raspberry_Pi}, \\
    \url{https://www.raspberrypi.org/help/what-\%20is-a-raspberry-pi/}
    
\bibitem{arm32}
      Les architectures ARM sont des architectures de type RISC 32 bits. Dotés d'une architecture relativement plus simple que d'autres familles de processeurs et faibles consommateurs d'électricité, les processeurs ARM sont aujourd'hui dominants dans le domaine de l'informatique embarquée. C'est donc l'architecture des Raspberry Pi.
      Plus d'information à cette adresse:\\
      \url{https://fr.wikipedia.org/wiki/Architecture_ARM}
      
 \bibitem{desktopenv}
 	En informatique, un environnement de bureau (de l'anglais desktop environment) est l' interface utilisateur graphique qui ressemble à un bureau. 
    Plus d'information à cette adresse: \\
    \url{https://fr.wikipedia.org/wiki/Environnement_de_bureau}

\bibitem{git}
    Git permet de gérer les versions et de collaborer sur un projet. Plus d'information à cette adresse: \\
    \url{https://git-scm.com/}

\bibitem{unityyaml}
    UnityYAML est un format de fichier optimisé par Unity pour stocker des scènes, basé sur le format YAML (\url{https://yaml.org/}) mais ne supportant qu'un sous-ensemble des spécifications. Plus d'informations à cette adresse: \\
    \url{https://docs.unity3d.com/Manual/UnityYAML.html}
    
\bibitem{yamldotnet}
    YamlDotNet est une librairie pour l'engin dotnet qui permet de parser du YAML. Nous l'utilisons en partie pour l'interprétation des scènes sur le serveur, comme UnityYAML\cite{unityyaml} est un sous-ensemble de YAML. Plus d'informations à cette adresse: \\
    \url{https://github.com/aaubry/YamlDotNet}
    
\bibitem{parser}
	En informatique, un parser est programme est un composant logiciel qui prend des données d'entrée (souvent du texte) et les transforment en représentation compréhensibles par ce dernier. Plus d'informations à cette addresse: \\
    \url{https://fr.wikipedia.org/wiki/Analyse_syntaxique}
    
\bibitem{yaml}
	YAML (YAML Ain't Markup Language) est un langage de sérialisation de données lisible par l'homme. Il est couramment utilisé pour les fichiers de configuration et dans les applications où les données sont stockées ou transmises. YAML ressemble dans son usage au JSON et XML. Il utilise l'indentation de style Python pour indiquer l'imbrication et est facilement extensible. Plus d'informations à cette addresse: \\
    \url{https://fr.wikipedia.org/wiki/YAML}
    
\bibitem{tcp}
    Le protocole TCP (Transmission Control Protocol) permet le transfert fiable de données entre ordinateurs sur le même réseau. Contrairement au protocole UDP, il est orienté sur des connections et garanti l'ordre des paquets. Documentation officielle accessible ici: \\
    \url{https://www.rfc-editor.org/rfc/rfc9293.html}
    
\bibitem{udp}
    Le protocole UDP (User Datagram Protocol) est un protocole permettant la transmission rapide de données entre ordinateurs sur le même réseau. UDP ne garantit ni l'ordre ni l'arrivée des paquets. Il est cependant bien plus rapide que le protocole TCP. Documentation officielle accessible ici: \\
    \url{https://www.rfc-editor.org/rfc/rfc768.html}
    
\bibitem{trello}
	Trello est un outil de gestion de projet en ligne. Il repose sur une organisation des projets en planches listant des cartes, chacune représentant des tâches. Les cartes sont assignables à des utilisateurs et sont mobiles d'une planche à l'autre, traduisant leur avancement. C'est l'outil que nous avons utilisé pour décider qui ferait quoi. Plus d'informations à ces adresses: \\
    \url{https://fr.wikipedia.org/wiki/Trello} \\
    \url{https://trello.com/fr}
    
\bibitem{tileset}
	Un tileset (ensemble de tuiles en français) est un ensemble d'images de même taille permettant de créer facilement des environnements.
    
\bibitem{namespace} 
  Les programmes C\# sont organisés à l’aide de namespace. Ces derniers sont utilisés à la fois en tant que système d’organisation interne pour un programme, et en tant que système d’organisation externe, ce qui permet de présenter les éléments de programme qui sont exposés à d’autres programmes. Plus d'informations à ces addresses: \\
  \url{https://learn.microsoft.com/fr-fr/dotnet/csharp/language-reference/language-specification/namespaces}

\end{thebibliography}






\newpage
\appendix
\section{Paquets}
\label{annexe:paquets}
\subsection{ServerPackets (envoyés du serveur au client)}
\paragraph{Welcome}
Premier message envoyé par le serveur, sert à donner un ID au client.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{2}*{1} & \multirow{2}*{TCP} & message & string & Message de bienvenue, toujours défini comme "Welcome to the server!", utilisé uniquement pour débogage. \\
    \cline{3-5}
    & & clientId & int & Id du nouveau client \\
\hline
\end{tabular}
\end{center}

\paragraph{Spawn Player}
Envoyé par le serveur lorsqu' un nouveau  joueur rejoint la partie, aussi envoyé au joueur se connectant.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{4}*{2} & \multirow{4}*{TCP} & client id & int & ID du joueur (identique à son ID client) \\
    \cline{3-5}
    & & username & string & Nom du joueur \\
    \cline{3-5}
    & & position & Vector2 & Position du joueur(0:0 représente le milieu de l’écran) \\
    \cline{3-5}
    & & rotation & float & Rotation de l’arme du joueur, en degré, sens trigonométrique, 0o est à l’horizontale à droite \\
    \hline
\end{tabular}
\end{center}

\paragraph{Disconnect Player}
Envoyé par le serveur aux joueurs restants lorsque un joueur averti le serveur qu’il se déconnecte.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{1}*{3} & \multirow{1}*{TCP} & \multicolumn{3}{|l|}{(aucun)} \\
    \hline
\end{tabular}
\end{center}

\paragraph{Set Name}
Envoyé par le serveur à tous les joueurs lorsqu' un joueur change son nom.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{2}*{4} & \multirow{2}*{TCP} & client id & int & ID du joueur \\
    \cline{3-5}
    & & username & string & Nom du joueur \\
    \hline
\end{tabular}
\end{center}

\paragraph{Start Game}
Envoyé par le serveur à tous les joueurs au début d’une partie
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{2}*{5} & \multirow{2}*{TCP} & duration & float & Durée de la partie, en secondes \\
    \cline{3-5}
    & & map id & int & ID de la map, >0 car 0 représente la salle d’attente. \\
    \hline
\end{tabular}
\end{center}

\paragraph{End Game}
Envoyé par le serveur à tous les joueurs à la fin d’une partie
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{1}*{6} & \multirow{1}*{TCP} & \multicolumn{3}{|l|}{(aucun)} \\
    \hline
\end{tabular}
\end{center}

\paragraph{Game Time}
Envoyé par le serveur à chaque tic pour les informer du temps restant.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{1}*{7} & \multirow{1}*{UDP} & \multicolumn{3}{|l|}{(aucun)} \\
    \hline
\end{tabular}
\end{center}

\paragraph{Player Position}
Envoyé par le serveur à tous les joueurs lorsqu'un joueur bouge.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{2}*{8} & \multirow{2}*{UDP} & client id & int & ID du joueur \\
    \cline{3-5}
    & & position & Vector2 & Position du joueur \\
    \hline
\end{tabular}
\end{center}

\paragraph{Player Rotation}
Envoyé par le serveur à tous les joueurs lorsqu'un joueur tourne.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{2}*{9} & \multirow{2}*{UDP} & client id & int & ID du joueur \\
    \cline{3-5}
    & & rotation & float & Rotation du joueur \\
    \hline
\end{tabular}
\end{center}

\paragraph{Player Respawned}
Envoyé par le serveur à tous les joueurs lorsqu'un joueur réapparaît.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{1}*{12} & \multirow{1}*{TCP} & \multicolumn{3}{|l|}{(aucun)} \\
    \hline
\end{tabular}
\end{center}

\paragraph{Player Hit}
Envoyé par le serveur à tous les joueurs lorsqu'un joueur est touché par un projectile.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{2}*{10} & \multirow{2}*{TCP} & client id & int & ID du joueur touché \\
    \cline{3-5}
    & & by & int & ID du joueur ayant tiré le projectile \\
    \hline
\end{tabular}
\end{center}

\paragraph{Player Ammo}
Envoyé par le serveur au joueur lorsqu’il tire ou récupère une arme pour l’informer du nombre de balles qu’il possède.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{1}*{11} & \multirow{1}*{TCP} & \multicolumn{3}{|l|}{(aucun)} \\
    \hline
\end{tabular}
\end{center}

\paragraph{Item Spawned}
Envoyé par le serveur à tous les joueurs lorsqu'un objet apparaît. 
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{3}*{13} & \multirow{3}*{TCP} & item id & int & ID de l’objet \\
    \cline{3-5}
    & & position & Vector2 & Position de l’objet \\
    \cline{3-5}
    & & type & int & Type de l’objet. (pistolet, fusil, mitraillette,...) \\
    \hline
\end{tabular}
\end{center}

\paragraph{Item Picked Up}
Envoyé par le serveur à tous les joueurs lorsqu'un objet est récupéré par un joueur. 
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{2}*{14} & \multirow{2}*{TCP} & item id & int & ID de l’objet \\
    \cline{3-5}
    & & client id & int & ID du joueur \\
    \hline
\end{tabular}
\end{center}

\paragraph{Projectile Spawned}
Envoyé par le serveur à tous les joueurs lorsqu'un projectile est tiré.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{3}*{15} & \multirow{3}*{TCP} & projectile id & int & ID du projectile \\
    \cline{3-5}
    & & position & Vector2 & Position du projectile \\
    \cline{3-5}
    & & client id & int & ID du joueur qui a tiré le projectile \\
    \hline
\end{tabular}
\end{center}

\paragraph{Projectile Position}
Envoyé par le serveur à tous les joueurs lorsqu'un projectile bouge.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
\hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{2}*{16} & \multirow{2}*{UDP} & projectile id & int & ID du projectile \\
    \cline{3-5}
    & & position & Vector2 & Position du projectile \\
    \hline
\end{tabular}
\end{center}

\paragraph{Projectile Destroyed}
Envoyé par le serveur à tous les joueurs lorsqu'un projectile est détruit.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{1}*{17} & \multirow{1}*{TCP} & \multicolumn{3}{|l|}{(aucun)} \\
    \hline
\end{tabular}
\end{center}

\subsection{Client Packets (envoyés du client au serveur)}
\paragraph{Welcome Received}
Premier message envoyé par le client, sert à confirmer l’ID du client.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{1}*{1} & \multirow{1}*{TCP} & \multicolumn{3}{|c|}{(aucun)} \\
    \hline
\end{tabular}
\end{center}

\paragraph{Player Name}
Envoyé au serveur lorsque le joueur change son nom
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{1}*{2} & \multirow{1}*{TCP} & \multicolumn{3}{|c|}{(aucun)} \\
    \hline
\end{tabular}
\end{center}

\paragraph{Player Movement}
Envoyé au serveur à chaque tic, contient les boutons que le joueur presse ainsi que sa rotation.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{3}*{3} & \multirow{3}*{UDP} & inputs length & int & Taille de la liste de boutons \\
    \cline{3-5}
    & & inputs & list [bool] & État des boutons: false = normal, true = pressé \\
    \cline{3-5}
    & & rotation & float & Rotation du joueur (angle entre l’horizon, le joueur et la souris) \\
    \hline
\end{tabular}
\end{center}

\paragraph{Player Shoot}
Envoyé au serveur quand le client clique.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{1}*{4} & \multirow{1}*{TCP} & \multicolumn{3}{|c|}{(aucun)} \\
    \hline
\end{tabular}
\end{center}

\paragraph{Player End Game}
Envoyé au serveur quand le client appuie sur le bouton Continue quand la partie est finie. Signal au serveur que le joueur est prêt à jouer à nouveau.
\begin{center}
\begin{tabular}{|p{1.5cm}|p{1.7cm}|p{1.9cm}|p{1.2cm}|p{6.7cm}|}
    \hline
    Packet Id & UDP/TCP & Nom & Type & Note \\
    \hline\hline
    \multirow{1}*{5} & \multirow{1}*{TCP} & \multicolumn{3}{|c|}{(aucun)} \\
    \hline
\end{tabular}
\end{center}

\end{document}
